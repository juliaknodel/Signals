# Большая лабораторная

## Базовая постановка задачи:

### Выбранные объекты:
+ Объект А - арка в форме буквы П, однотонная

+ Объект Б - любой прямоугольный объект, однотонный

### Требования к фото на входе:
+ Формат: png, jpg

+ Минимальное разрешение: 800x600

+ Освещение: искусственное или естественное, без резких теней, на фото не должно быть пересвеченных или абсолютно черных областей.

+ Не шумное, резкое, не смазанное, объекты А и Б должны быть на 100% в фокусе.

+ На фото должны находиться два объекта А и Б, которые не пересекаются и не соприкасаются, полностью помещаются на фото, между объектами и границами фотографии есть зазоры. 

### Допущения вне зависимости от пришедшей на вход фотографии:
+ Считается, что объекты А и Б находятся на одинаковом удалении от камеры. 
  > Как рассчитывается расстояние: камера принимается за точку. Расстоянием считается кратчайший путь от камеры до точки принадлежащей объекту.

+ Считается, что оба объекта А и Б плоские и находятся в одной плоскости, параллельной той, в которой сделана фотография.

+ Считается, что арка стоит на полу, то есть нижняя граница арки лежит в плоскости пола.



### Задача:
На вход подается фото, удовлетворяющее критериям описанным выше.

### Требуется: 
+ Распознать на фото объекты А и Б == выделить четырехугольную область В внутри объекта А, в которую могут проходить другие объекты (3 края данной области описываются границами арки А, а четвертая граница полом). 

+ Установить пройдет ли объект Б под арку А (иными словами, поместится ли он в области В), при параллельном переносе объекта Б.

## Дополнительное задание:
> Указать, на сколько градусов по часовой стрелке надо повернуть объект Б относительно его центра, чтобы после параллельного переноса он влез в арку, если это возможно. За центр объекта Б принимается точка пересечения диагоналей найденного четырехугольника (в терминах пикселей: средний пиксель из занимаемых объектом по горизонтальной оси и аналогично средний по вертикальной оси).



## Структура репозитория
.ipynb и .py файлы лежат в папке /src:

> .py содержит чистый код классификатора

> .ipynb содержит фактически тот же код, но там приведены примеры использования и пример с пошаговым выводом результатов исполнения ячеек

Примеры входных изображений находятся в папке /data:
> class_0 - примеры, которые при базовой постановке задачи  (без возможности поворота блокнота) являются отрицательными (то есть блокнот при параллельном переносе не влезет в арку)

> class_1 - положительные пример (блокнот влезет в арку)


## Текущий прогресс

Реализован алгоритм решения задачи в базовой постановке (блокнот может быть перенесен только с помощью параллельного переноса).
Использована бинаризация и условие, что арка стоит ровно => ищутся прямоугольники:
+ Минимальный прямоугольник, который может быть описан вокруг блокнота. На данном этапе стороны прямоугольника параллельны осям фотографии.

+ Максимальный прямоугольник, который может быть вписан во внутреннюю часть арки. По предположению в постановке арка стоит ровно, поэтому стороны прямоугольника также параллельны осям фотографии.

Далее просто проверяется, что ширина и высота прямоугольника найденного для блокнота оказываются соответственно меньше ширины и высоты прямоугольника, найденного для арки.
Если это условие выполнено, то алгоритм выдает положительный ответ о возможности блокнота пролезть через арку. И наоборот в противном случае.

### По шагам:
1. После сглаживания изображения и бинаризации получаем маску объектов на изображении.
2. Используем предположение, что площади блокнота и арки самые большие на изображении (площадь блокнота > площади арки) => добавляется предположени о том, что на сцене могут присутствовать либо только эти два объекта, либо все посторонние объекты будут меньше (датасет данному условию удовлетворяет). Выделяем компоненты связностина маске и получаем маски блокнота и арки в отдельности, просто получая 1 и 2 по величине площади комп. связности.
3. По маске для блокнота находим индексы крайних пикселей (левый, правый, верхний, нижний)
    + Левый/правый: находим столбцы, в которых есть хотя бы одно True (== хотя бы 1 белый пиксель), выделяем индексы тех столбцов, в которых это условие выполняется. Первый индекс - левый край, последний индекс - правый край.
    + Верхний/нижний: находим строки, в которых есть хотя бы одно True, выделяем индексы тех строк, где это условие выполняется. Первый индекс - верхний край, последний индекс - нижний край.
4. По маске для арки аналогично методу с блокнотом находим внешние границы арки.
5. Внутренние границы арки будем искать по маске для арки, но уже ограниченной внешними границами арки найденными в п.4.
    + Левая/правая внутренняя границы: находим столбцы, в которых более 70% пикселей - черные. Аналогично выделяем индексы тех столбцов, в которых условие выполняется. Первый индекс - левая внутрення граница, последний индекс - правая внутренняя граница.
    + Верхняя/нижняя внутренние границы: находим строки, в которых более 70% пикселей - черные. Аналогично выделяем индексы тех строк, в которых условие выполняется. Первый индекс - верхняя граница, последний индекс - нижняя внутренняя граница (хотя нижнюю можно и не искать, так как она совпадает с внешней нижней границей).
6. Имея границы внутреннего прямоугольника, вписанного в арку, и прямоугольника описанного вокруг блокнота можно проверить влезет ли второй прямоугольник в первый. Тут пользуемся условием, что для блокнота допустим только параллельный перенос (это также дало возможность сделать стороны прямоугольника параллельными осям фотографии) и просто проверяем, что ширина и высота прямоугольника блокнота окажутся меньше, чем ширина и высота прямоугольника внутри арки.

### Точность на текущем датасете:

Пока считаю....

### Проблемы и задумки:
Для будущей реализации доп. задачи очевидно необходимо выделять повернутый прямоугольник объекта блокнот, но на данном этапе почему-то даже для бинаризвоанной картинки (а бинаризация получается вполне себе неплохая в большинстве случаев) очень сложно выделить прямоугольники.

Что я пыталась сделать:

1. Заиметь шаблон - не помогло, он просто не детектит ничего, видимо потому что особые точки у него - весь блокнот, так как он однотонный и зацепиться не за что. 

2. На части фотографий получилось выделить некоторые прямоугольники с помощью FindContours, в которых присутствовал тот самый блокнот, но и посторонние прямоугольники также (эта часть фотографий, которую я подгрузила после сохранения и они оказались с белыми рамками). Но чистая та же самая фотография без рамок и тд - не находит вообще никаких контуров. Я предполагаю, что это связано с качеством сохраненной фотографии (оно ниже, чем исходная) и видимо границы блокнота сгладились (хотя они и исходно не то, чтобы сильно плохи), и вписать прямоугольник в него стало легче.

В общем это уже видимо для второй итерации - попытаться таки найти нужный повернутый прямоугольник по бинаризованной картинке.

Также в процессе возник момент с тем, что пришлось добавить условие на отсутствие других объектов в кадре (либо объектов больших по площади). Если я не буду работать с будущем с шаблоном (надо подумать, что надо такого сделать, чтобы это заработало), то это условие будет одним из основных требуемых.

